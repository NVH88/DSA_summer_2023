//code cây nhị phân tìm kiếm cân bằng

#include<bits/stdc++.h>
using namespace std;

struct Node{
    int data, height;
    Node *left, *right;

    Node(int x) {
        data = x; height = 0;
        left = right = nullptr;
    }
};

int getHeight(Node *x) {
    if(x == nullptr) reutrn 0;
    return x->height;
}

int getBalance(Node *x) { //= 0: can bang, < 0: lech phai, > 0: lech trai
    if(x == nullptr) return 0;
    return getHeight(x->left) - getHeight(x->right);
}

Node *leftRotate(Node *root) { // xoay trái
    Node *x = root->right;
    Node *y = x->left;

    root->right = y;
    x->left = root;

    root->height = 1 + max(getHeight(root->left), getHeight(root->right));
    x->height = 1 + max(getHeight(x->left), getHeight(x->right));

    return x;
}

Node *rightRotate(Node *root) { // xoay phải
    Node *x = root->left;
    Node *y = x->right;

    root->left = y;
    x->right = root;
    
    root->height = 1 + max(getHeight(root->left), getHeight(root->right));
    x->height = 1 + max(getHeight(x->left), getHeight(x->right));

    return x;
}

Node *insert(Node *root, int val) {
    if(root == nullptr) return new Node(val);

    if(root->data > val) root->left = insert(root->left, val);
    else if(root->data < val) root->right = insert(root->right, val);
    else return root;

    root->height = 1 + max(getHeight(root->left), getHeight(root->right));

    int balance = getBalance(root);

    if(balance > 1 && val < root->left->data) { //left left case
        return rightRotate(root);
    }

    if(balance < -1 && val > root->right->data) { //right right case
        return leftRotate(root);
    }

    if(balance > 1 && val > root->left->data) { //left right case
        root->left = leftRotate(root->right);
        return rightRotate(root);
    }

    if(balance < -1 && val < root->right->data) { //right left case
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

Node *deleteNode(Node *root, int val) {
    if(root == nullptr) return root;

    if(root->data > val) root->left = deleteNode(root->left, val);
    else if(root->data < val) root->right = deleteNode(root->right, val);
    else {
        if(root->left == nullptr && root->right == nullptr) {
            delete root;
            return nullptr;
        }

        else if(root->right == nullptr) {
            Node *x = root->left;
            delete root;
            return x;
        }

        else if(root->left == nullptr) {
            Node *x = root->right;
            delete root;
            return x;
        }

        Node *x = root->right;
        while(x->left != nullptr) x = x->left;
        root->data = x->data;
        root->right = deleteNode(root->right, x->data);
    }

    if(root == nullptr) return root; //node cần xóa

    root->height = 1 + max(getHeight(root->left), getHeight(root->r));
    int balance = getBalance(root);

    if(balance > 1 && val < root->left->data) {// left left case
        return rightRotate(root);
    }

    if(balance < -1 && val > root->right->data) {// right right case
        return leftRotate(root);
    }

    if(balance > 1 && val > root->left->data) {// left right case
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    if(balance < -1 && val < root->right->data) {// right left case
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    #ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    #endif
    

}
